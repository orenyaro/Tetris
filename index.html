<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>טטריס – משחק דפדפן</title>
<style>
  :root { --bg:#0e0f13; --fg:#e8e8e8; --grid:#202532; --accent:#6ee7ff; }
  * { box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html, body { margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  header { text-align:center; padding:8px 12px; line-height:1.2; }
  header h1 { font-size:18px; margin:6px 0 0; font-weight:700; }
  header .stats { display:flex; justify-content:center; gap:16px; font-size:14px; opacity:.9; }
  #gamewrap { display:flex; justify-content:center; align-items:flex-start; padding:8px 8px 80px; }
  #board { background:var(--grid); border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,.35); touch-action:none; }
  #msg { position:fixed; inset:auto 12px 120px 12px; background:rgba(0,0,0,.6); color:#fff; border:1px solid rgba(255,255,255,.15); padding:10px 12px; border-radius:8px; font-size:14px; line-height:1.35; backdrop-filter: blur(6px); }
  #controls { position:fixed; left:0; right:0; bottom:0; padding:10px 12px 14px; display:grid; grid-template-columns:1.2fr .8fr 1.2fr; gap:10px; background:linear-gradient(180deg, rgba(14,15,19,0) 0%, rgba(14,15,19,.85) 40%, rgba(14,15,19,.95) 100%); }
  .btnrow { display:flex; gap:10px; justify-content:space-between; }
  button { appearance:none; border:none; background:#1c2230; color:#dfe6f3; font-weight:700; border-radius:12px; padding:14px 12px; font-size:16px; min-height:52px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 4px 14px rgba(0,0,0,.3); }
  button:active { transform: translateY(1px); }
  .ghost { opacity:.5 }
  .small { font-size:13px; font-weight:600; }
  .col { display:flex; flex-direction:column; gap:10px; }
  .hidden { display:none !important; }
  .bad { color:#ff9fa2; }
  .good { color:#b0ffb4; }
  footer { position:fixed; right:10px; top:10px; opacity:.5; font-size:12px }
  @media (min-width: 768px) {
    header h1 { font-size:22px; }
    #gamewrap { padding-bottom:110px; }
    button { min-height:56px; font-size:17px; }
  }
</style>
</head>
<body>
  <header>
    <div class="stats"><div>ניקוד: <b id="score">0</b></div><div>שלב: <b id="level">1</b></div><div>שורות: <b id="lines">0</b></div></div>
    <h1>טטריס</h1>
  </header>
  <div id="gamewrap">
    <canvas id="board" width="300" height="600" aria-label="לוח משחק"></canvas>
  </div>

  <div id="msg" class="hidden"></div>

  <div id="controls">
    <div class="btnrow">
      <button id="left">◀︎ שמאלה</button>
      <button id="rotate">⟳ סיבוב</button>
      <button id="right">ימינה ▶︎</button>
    </div>
    <div class="btnrow">
      <button id="soft" class="ghost small">⬇︎ נפילה מהירה</button>
      <button id="hard" class="small">⬇︎⬇︎ נפילה מידית</button>
      <button id="pause" class="small">⏸︎ השהה</button>
    </div>
  </div>

  <footer>גרסה: דפדפן, קובץ יחיד</footer>

<script>
(function(){
  const COLS = 10, ROWS = 20;
  const EMPTY = 0;
  const SHAPES = {
    I: [[1,1,1,1]],
    J: [[2,0,0],[2,2,2]],
    L: [[0,0,3],[3,3,3]],
    O: [[4,4],[4,4]],
    S: [[0,5,5],[5,5,0]],
    T: [[0,6,0],[6,6,6]],
    Z: [[7,7,0],[0,7,7]]
  };
  const COLORS = {
    1:"#6ee7ff", 2:"#a78bfa", 3:"#f59e0b", 4:"#fbbf24", 5:"#4ade80", 6:"#ec4899", 7:"#ef4444"
  };

  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const msgEl = document.getElementById('msg');

  // Responsive sizing
  function resize() {
    const vw = Math.min(window.innerWidth, 600);
    const vh = window.innerHeight - 200;
    const sz = Math.floor(Math.min(vw/ COLS, vh / ROWS));
    canvas.width = sz * COLS;
    canvas.height = sz * ROWS;
    cell = sz;
    draw();
  }
  let cell = 30;
  window.addEventListener('resize', resize);

  // Game state
  let grid = createMatrix(COLS, ROWS);
  let bag = [];
  let piece = null;
  let nextDrop = 800; // ms
  let lastTime = 0;
  let acc = 0;
  let running = true;
  let score = 0;
  let level = 1;
  let lines = 0;

  function createMatrix(w,h){
    return Array.from({length:h}, ()=>Array(w).fill(EMPTY));
  }
  function copyMatrix(m){ return m.map(r=>r.slice()); }

  function newPiece(){
    if (bag.length === 0) bag = shuffle(Object.keys(SHAPES));
    const type = bag.pop();
    return {
      type,
      matrix: copyMatrix(SHAPES[type]),
      x: Math.floor((COLS - SHAPES[type][0].length)/2),
      y: -1
    };
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]];} return a; }

  function collide(g, p){
    const m = p.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x] && (g[y+p.y] && g[y+p.y][x+p.x]) !== EMPTY){
          return true;
        }
        if (m[y][x] && (y+p.y)>=ROWS) return true;
        if (m[y][x] && (x+p.x)<0) return true;
        if (m[y][x] && (x+p.x)>=COLS) return true;
      }
    }
    return false;
  }

  function merge(g,p){
    for (let y=0;y<p.matrix.length;y++){
      for (let x=0;x<p.matrix[y].length;x++){
        if (p.matrix[y][x]){
          if (p.y + y < 0) continue;
          g[p.y+y][p.x+x] = p.matrix[y][x];
        }
      }
    }
  }

  function rotateMatrix(m){
    const N = m.length, M = m[0].length;
    const res = Array.from({length:M}, ()=>Array(N).fill(0));
    for (let y=0;y<N;y++) for (let x=0;x<M;x++){ res[x][N-1-y] = m[y][x]; }
    return res;
  }

  function clearLines(){
    let cleared = 0;
    outer: for (let y=ROWS-1;y>=0;y--){
      for (let x=0;x<COLS;x++){ if (grid[y][x] === EMPTY) { continue outer; } }
      grid.splice(y,1);
      grid.unshift(Array(COLS).fill(EMPTY));
      cleared++; y++;
    }
    if (cleared){
      const points = [0, 40, 100, 300, 1200][cleared] * level;
      score += points;
      lines += cleared;
      if (lines >= level*10){
        level++;
        nextDrop = Math.max(90, 800 - (level-1)*70);
        showMsg("עלית לשלב " + level + "!", 1000, "good");
      }
      updateStats();
    }
  }

  function updateStats(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  function drawCell(x,y,val){
    if (!val) return;
    ctx.fillStyle = COLORS[val] || "#9ca3af";
    ctx.fillRect(x*cell, y*cell, cell, cell);
    ctx.fillStyle = "rgba(255,255,255,.12)";
    ctx.fillRect(x*cell, y*cell, cell, 4);
    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.fillRect(x*cell, y*cell + cell-4, cell, 4);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    // background grid
    ctx.save();
    ctx.globalAlpha = 0.15;
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        ctx.strokeStyle = "#ffffff15";
        ctx.strokeRect(x*cell, y*cell, cell, cell);
      }
    }
    ctx.restore();

    // draw grid
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        drawCell(x,y,grid[y][x]);
      }
    }
    // draw current piece
    if (piece){
      // ghost drop preview
      let ghostY = piece.y;
      while(!collide(grid, {...piece, y: ghostY+1})) ghostY++;
      ctx.save();
      ctx.globalAlpha = .25;
      for (let y=0;y<piece.matrix.length;y++){
        for (let x=0;x<piece.matrix[y].length;x++){
          if (piece.matrix[y][x]){
            drawCell(piece.x + x, ghostY + y, piece.matrix[y][x]);
          }
        }
      }
      ctx.restore();

      for (let y=0;y<piece.matrix.length;y++){
        for (let x=0;x<piece.matrix[y].length;x++){
          if (piece.matrix[y][x]){
            drawCell(piece.x + x, piece.y + y, piece.matrix[y][x]);
          }
        }
      }
    }
  }

  function drop(){
    if (!piece) return;
    piece.y++;
    if (collide(grid, piece)){
      piece.y--;
      merge(grid, piece);
      clearLines();
      piece = newPiece();
      if (collide(grid, piece)){
        running = false;
        showMsg("המשחק נגמר! ניקוד: " + score + ". הקש/י על ⏯︎ כדי להתחיל מחדש.", 2500, "bad");
      }
    }
    draw();
  }

  function hardDrop(){
    if (!piece) return;
    while(!collide(grid, {...piece, y: piece.y+1})) piece.y++;
    drop();
  }

  function move(dir){
    if (!piece) return;
    piece.x += dir;
    if (collide(grid, piece)) piece.x -= dir;
    draw();
  }

  function rotate(){
    if (!piece) return;
    const rotated = rotateMatrix(piece.matrix);
    const oldX = piece.x;
    piece.matrix = rotated;
    // simple wall kicks
    const kicks = [0, -1, 1, -2, 2];
    for (const k of kicks){
      piece.x = oldX + k;
      if (!collide(grid, piece)){ draw(); return; }
    }
    piece.x = oldX; // revert if none fit
    piece.matrix = rotateMatrix(rotateMatrix(rotateMatrix(rotated))); // revert rotation
  }

  function tick(time=0){
    if (!running) { lastTime = time; requestAnimationFrame(tick); return; }
    const dt = time - lastTime;
    lastTime = time;
    acc += dt;
    if (acc > nextDrop){
      drop();
      acc = 0;
    }
    requestAnimationFrame(tick);
  }

  function showMsg(text, ms=1200, cls=""){
    msgEl.textContent = text;
    msgEl.classList.remove("hidden","bad","good");
    if (cls) msgEl.classList.add(cls);
    const id = ++showMsg._id;
    msgEl.classList.remove("hidden");
    setTimeout(()=>{ if (id===showMsg._id) msgEl.classList.add("hidden"); }, ms);
  }
  showMsg._id = 0;

  // Controls
  const leftBtn = document.getElementById('left');
  const rightBtn = document.getElementById('right');
  const rotateBtn = document.getElementById('rotate');
  const softBtn = document.getElementById('soft');
  const hardBtn = document.getElementById('hard');
  const pauseBtn = document.getElementById('pause');

  let holdIntervals = new Map();
  function holdable(btn, fn, initialDelay=180, repeat=70){
    const start = (e)=>{
      e.preventDefault();
      fn();
      const id = setTimeout(()=>{
        const rep = setInterval(fn, repeat);
        holdIntervals.set(btn, rep);
      }, initialDelay);
      holdIntervals.set(btn, id);
    };
    const end = ()=>{
      const t = holdIntervals.get(btn);
      if (t){ clearTimeout(t); clearInterval(t); holdIntervals.delete(btn); }
    };
    btn.addEventListener('touchstart', start, {passive:false});
    btn.addEventListener('mousedown', start);
    ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>btn.addEventListener(ev, end));
  }

  holdable(leftBtn, ()=>move(-1));
  holdable(rightBtn, ()=>move(1));
  rotateBtn.addEventListener('click', (e)=>{ e.preventDefault(); rotate(); });
  softBtn.addEventListener('click', (e)=>{ e.preventDefault(); drop(); });
  hardBtn.addEventListener('click', (e)=>{ e.preventDefault(); hardDrop(); });

  pauseBtn.addEventListener('click', e=>{
    e.preventDefault();
    if (!piece || !running){
      // restart
      grid = createMatrix(COLS, ROWS);
      bag = [];
      piece = newPiece();
      running = true;
      score = 0; level = 1; lines = 0; nextDrop = 800;
      updateStats(); draw(); showMsg("בהצלחה!");
      return;
    }
    running = !running;
    pauseBtn.textContent = running ? "⏸︎ השהה" : "⏯︎ המשך";
    showMsg(running ? "ממשיך" : "הופסק");
  });

  // Swipe controls
  let startX=null, startY=null, startT=0;
  canvas.addEventListener('touchstart', (e)=>{
    if (!piece) return;
    const t = e.changedTouches[0];
    startX = t.clientX; startY = t.clientY; startT = Date.now();
  }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    if (startX===null) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;
    const dt = Date.now() - startT;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    const SWIPE = 24;
    if (dt < 300 && ax < 10 && ay < 10){
      rotate(); // tap
    } else if (ax > ay && ax > SWIPE){
      move(dx>0 ? 1 : -1);
    } else if (ay > ax && ay > SWIPE){
      if (dy>0) hardDrop(); else rotate();
    }
    startX = startY = null;
  }, {passive:true});

  // Keyboard (for desktop testing)
  window.addEventListener('keydown', (e)=>{
    if (!piece) return;
    switch (e.key){
      case "ArrowLeft": move(-1); break;
      case "ArrowRight": move(1); break;
      case "ArrowUp": rotate(); break;
      case "ArrowDown": drop(); break;
      case " ": hardDrop(); e.preventDefault(); break;
      case "p": case "P": running=!running; break;
    }
  });

  // Start
  piece = newPiece();
  resize();
  updateStats();
  requestAnimationFrame(tick);
  showMsg("טיפ: הקש/י על הקנבס לסיבוב, החלק שמאלה/ימינה להזזה, ולמטה לנפילה מידית.", 2500);

})(); 
</script>
</body>
</html>